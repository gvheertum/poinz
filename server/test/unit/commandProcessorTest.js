import {v4 as uuid} from 'uuid';
import {newMockRoomsStore} from './testUtils';
import processorFactory, {sanitizeRoomId} from '../../src/commandProcessor';
import {baseCommandSchema} from '../../src/commandHandlers/commandHandlers';

test('process a dummy command successfully: create room on the fly', async () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        skipUserIdRoomCheck: true,
        fn: (pushEvent, room, command) => pushEvent('propertySetEvent', command.payload),
        schema: {$ref: 'command'}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room, eventPayload) => ({
        id: room.id,
        stories: [
          {
            id: uuid(),
            createdAt: Date.now(),
            title: eventPayload.payloadProperty,
            description: 'data.from.evt.handler'
          }
        ],
        users: [],
        created: Date.now()
      })
    },
    newMockRoomsStore() //  no room exists in store
  );

  const commandId = uuid();
  const {producedEvents, room} = await processor(
    {
      roomId: 'custom-room-id',
      id: commandId,
      name: 'setPropertyCommand',
      payload: {
        payloadProperty: 'command-payload-property'
      }
    },
    'abc'
  );

  expect(producedEvents).toMatchEvents(
    commandId,
    producedEvents[0].roomId, // id is generated by commandprocessor
    'propertySetEvent'
  );

  expect(room).toBeDefined();
  expect(room.id).toBe('custom-room-id');
  expect(room.stories[0].title).toEqual('command-payload-property');
  expect(room.stories[0].description).toEqual('data.from.evt.handler');
});

test('process a dummy command successfully: room loading by id', () => {
  const roomId = 'some-room-id_' + uuid();
  const roomStore = newMockRoomsStore({
    id: roomId,
    created: Date.now(),
    stories: [],
    users: [],
    lastActivity: Date.now() + 1111,
    markedForDeletion: false
  });
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        skipUserIdRoomCheck: true,
        fn: (pushEvent, room, command) => pushEvent('propertySetEvent', command.payload),
        schema: {$ref: 'command'}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room, eventPayload) => ({
        ...room,
        stories: [
          {
            id: uuid(),
            createdAt: Date.now(),
            title: eventPayload.payloadProperty,
            description: 'data.from.evt.handler'
          }
        ]
      })
    },
    roomStore
  );

  const commandId = uuid();
  return processor(
    {
      id: commandId,
      roomId: roomId,
      name: 'setPropertyCommand',
      payload: {
        payloadProperty: 'john'
      }
    },
    uuid()
  ).then(({producedEvents, room}) => {
    expect(producedEvents).toMatchEvents(commandId, roomId, 'propertySetEvent');

    expect(room).toBeDefined();
    expect(room.id).toBe(roomId);
    expect(room.stories[0].title).toEqual('john');
    expect(room.stories[0].description).toEqual('data.from.evt.handler');
  });
});

test('process a dummy command with No Handler ( and thus no schema )', () => {
  const processor = processorFactory(
    {
      // no command handlers
    },
    baseCommandSchema,
    {},
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'my-test-room',
        name: 'justACommand',
        payload: {
          prop: 'value'
        }
      },
      uuid()
    )
  ).rejects.toThrow('Cannot validate command, no matching schema found for "justACommand"!');
});

test('process a dummy command where event handler does not return room object', () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        skipUserIdRoomCheck: true,
        fn: (pushEvent) => {
          pushEvent('propertySetEvent', {});
        },
        schema: {$ref: 'command'}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: () => {
        return null;
      }
    },
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'my-test-room',
        name: 'setPropertyCommand',
        payload: {}
      },
      uuid()
    )
  ).rejects.toThrow(
    'Fatal error: Event Handlers must return the room object! event "propertySetEvent"'
  );
});

test('process a dummy command where event handler does return same room object', () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        skipUserIdRoomCheck: true,
        fn: (pushEvent) => {
          pushEvent('propertySetEvent', {});
        },
        schema: {$ref: 'command'}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room) => {
        room.someProperty = 'one';
        return room;
      }
    },
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'my-test-room',
        name: 'setPropertyCommand',
        payload: {}
      },
      uuid()
    )
  ).rejects.toThrow(
    'Fatal error: Event Handlers must not return same room object! event "propertySetEvent"'
  );
});

test('process a dummy command where command handler produced unknown event', () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        skipUserIdRoomCheck: true,
        fn: (pushEvent, room, command) => pushEvent('unknownEvent', command.payload),
        schema: {$ref: 'command'}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room) => ({...room, test: 'data.from.evt.handler'})
    },
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'some-room-id',
        name: 'setPropertyCommand',
        payload: {
          property: 'value'
        }
      },
      uuid()
    )
  ).rejects.toThrow('Cannot push unknown event unknownEvent');
});

test('process a dummy command where command precondition throws', () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        skipUserIdRoomCheck: true,
        preCondition: () => {
          throw new Error('Uh-uh. nono!');
        },
        fn: () => {},
        schema: {$ref: 'command'}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room) => ({...room, test: 'data.from.evt.handler'})
    },
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'some-room-id',
        name: 'setPropertyCommand',
        payload: {
          property: 'value'
        }
      },
      uuid()
    )
  ).rejects.toThrow('Precondition Error during "setPropertyCommand": Uh-uh. nono!');
});

test('process a dummy command where user does not belong to room', () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        // here "skipUserIdRoomCheck" flag is not set (same as in most handlers)
        schema: {$ref: 'command'},
        fn: () => {}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room) => ({...room, test: 'data.from.evt.handler'})
    },
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'some-room-id',
        name: 'setPropertyCommand',
        payload: {
          property: 'value'
        }
      },
      uuid()
    )
  ).rejects.toThrow(
    /Precondition Error during "setPropertyCommand": Given user .* does not belong to room some-room-id/g
  );
});

test('process a dummy command where command validation fails', () => {
  const processor = processorFactory({}, {}, newMockRoomsStore());

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'my-test-room',
        // no name -> cannot load appropriate schema
        payload: {}
      },
      'abc'
    )
  ).rejects.toThrow('Command validation Error during "undefined": Command must contain a name');
});

test('process a dummy command where command validation fails (schema)', () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        skipUserIdRoomCheck: true,
        fn: () => {},
        schema: {
          properties: {
            payload: {
              type: 'object'
            }
          },
          required: ['payload']
        }
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room) => ({
        ...room,
        test: 'data.from.evt.handler'
      })
    },
    newMockRoomsStore() //  no room exists in store
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'my-test-room',
        name: 'setPropertyCommand'
        // payload property is missing
      },
      uuid()
    )
  ).rejects.toThrow(
    'Command validation Error during "setPropertyCommand": Missing required property: payload'
  );
});

test('process a dummy command WITHOUT roomId: where room must exist', () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        fn: () => {},
        schema: {}
      }
    },
    baseCommandSchema,
    {},
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'some-room-id',
        name: 'setPropertyCommand',
        payload: {
          prop: 'value'
        }
      },
      uuid()
    )
  ).rejects.toThrow(
    // no roomId given in command. handler does not allow creation of new room
    'Command "setPropertyCommand" only wants to get handled for an existing room'
  );
});

test('process a dummy command WITH roomId: where room must exist', () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        fn: () => {},
        schema: {}
      }
    },
    baseCommandSchema,
    {},
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        id: uuid(),
        roomId: 'rm_' + uuid(),
        name: 'setPropertyCommand',
        payload: {
          prop: 'value'
        }
      },
      uuid()
    )
  ).rejects.toThrow(
    //  roomId is given in command, room does not exist. handler does not allow on-the-fly creation
    'Command "setPropertyCommand" only wants to get handled for an existing room!'
  );
});

/**
 * Assures that we handle two "simultaneously" incoming commands correctly.
 */
test('concurrency handling', async () => {
  const mockRoomsStore = newMockRoomsStore({
    id: 'concurrency-test-room',
    created: Date.now() - 12334,
    lastActivity: Date.now(),
    markedForDeletion: false,
    users: [],
    stories: []
  });

  const originalSave = mockRoomsStore.saveRoom;

  mockRoomsStore.saveRoom = jest.fn((rm) => originalSave(rm));
  mockRoomsStore.saveRoom.mockImplementationOnce((rm) => {
    return new Promise((resolve) => setTimeout(resolve, 20)).then(() => originalSave(rm));
  });

  const processor = processorFactory(
    {
      setPropertyCommand: {
        skipUserIdRoomCheck: true,
        fn: (pushEvent, room, command) => pushEvent('propertySetEvent', command.payload),
        schema: {}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room, eventPayload) => ({
        ...room,
        stories: [
          ...room.stories,
          {title: eventPayload.property, id: uuid(), createdAt: Date.now()}
        ]
      })
    },
    mockRoomsStore
  );

  const eventPromiseOne = processor(
    {
      id: uuid(),
      roomId: 'concurrency-test-room',
      name: 'setPropertyCommand',
      payload: {
        property: 'value-1'
      }
    },
    uuid()
  );
  const eventPromiseTwo = processor(
    {
      id: uuid(),
      roomId: 'concurrency-test-room',
      name: 'setPropertyCommand',
      payload: {
        property: 'value-2'
      }
    },
    uuid()
  );

  await Promise.all([eventPromiseOne, eventPromiseTwo]);

  const room = await mockRoomsStore.getRoomById('concurrency-test-room');

  expect(room.stories.length).toBe(2);
  expect(room.stories[0].title).toBe('value-1');
  expect(room.stories[1].title).toBe('value-2');

  expect(mockRoomsStore.saveRoom.mock.calls.length).toBe(2);
});

describe('sanitizeRoomId', () => {
  test('single whitespace', () => {
    const {roomId} = sanitizeRoomId({
      roomId: 'team estimating'
    });

    expect(roomId).toBe('team-estimating');
  });
  test('multiple whitespace', () => {
    const {roomId} = sanitizeRoomId({
      roomId: 'team  estimating'
    });

    expect(roomId).toBe('team--estimating');
  });
  test('%20', () => {
    const {roomId} = sanitizeRoomId({
      roomId: 'team%20estimating'
    });

    expect(roomId).toBe('team-estimating');
  });
  test('multiple %20', () => {
    const {roomId} = sanitizeRoomId({
      roomId: 'super%20team%20estimating'
    });

    expect(roomId).toBe('super-team-estimating');
  });
  test('missing roomId', () => {
    const {roomId} = sanitizeRoomId({});
    expect(roomId).toBeUndefined();
  });
});

test('detect structural problems in commandHandlers: no schema', () => {
  expect(() =>
    processorFactory(
      {
        setPropertyCommand: {
          fn: () => {}
          // no property "schema" defined
        }
      },
      baseCommandSchema,
      {},
      newMockRoomsStore()
    )
  ).toThrow(/Fatal error: CommandHandler "setPropertyCommand" does not define "schema"!/g);
});

test('detect structural problems in commandHandlers: schema is not an object, but a string', () => {
  expect(() =>
    processorFactory(
      {
        setPropertyCommand: {
          fn: () => {},
          schema: 'not-an-object' // <<- property "schema" must be an object
        }
      },
      baseCommandSchema,
      {},
      newMockRoomsStore()
    )
  ).toThrow(/Fatal error: "schema" on commandHandler "setPropertyCommand" must be an object!/g);
});

test('detect structural problems in commandHandlers: schema is not an object, but a function', () => {
  expect(() =>
    processorFactory(
      {
        setPropertyCommand: {
          fn: () => {},
          schema: () => true // <<- property "schema" must be an object
        }
      },
      baseCommandSchema,
      {},
      newMockRoomsStore()
    )
  ).toThrow(/Fatal error: "schema" on commandHandler "setPropertyCommand" must be an object!/g);
});

test('detect structural problems in commandHandlers: "fn" is not a function', () => {
  expect(() =>
    processorFactory(
      {
        setPropertyCommand: {
          fn: 'some-string', // <<- property "fn" must be a function  (the actual handler function)
          schema: {}
        }
      },
      baseCommandSchema,
      {},
      newMockRoomsStore()
    )
  ).toThrow(/Fatal error: "fn" on commandHandler "setPropertyCommand" must be a function!/g);
});

test('throws if modified room does not adhere to roomSchema', async () => {
  const processor = processorFactory(
    {
      setPropertyCommand: {
        canCreateRoom: true,
        skipUserIdRoomCheck: true,
        fn: (pushEvent, room, command) => pushEvent('propertySetEvent', command.payload),
        schema: {$ref: 'command'}
      }
    },
    baseCommandSchema,
    {
      propertySetEvent: (room) => ({
        id: room.id
        /* missing properties in room */
      })
    },
    newMockRoomsStore()
  );

  return expect(
    processor(
      {
        roomId: 'custom-room-id',
        id: uuid(),
        name: 'setPropertyCommand',
        payload: {
          payloadProperty: 'command-payload-property'
        }
      },
      uuid()
    )
  ).rejects.toThrow('Invalid room object: Missing required property: stories in');
});
